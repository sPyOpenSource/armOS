#include <SFE_BMP180.h>
#include <Wire.h>
#include <LSM303.h>
#include <Adafruit_L3GD20.h>
#include <Kalman.h>          // Source: https://github.com/TKJElectronics/KalmanFilter
#include <PID_v1.h>
#include <Servo.h> 

Servo myServo[4];

LSM303 compass;
SFE_BMP180 pressure;
Adafruit_L3GD20 gyro;

LSM303::vector<Kalman> kalAcc,kalMag;
LSM303::vector<double> E,N,mag;

LSM303::vector<double> setpoint = (LSM303::vector<double>){    0      ,    0      ,   0      };
LSM303::vector<double> output   = (LSM303::vector<double>){    0      ,    0      ,   0      };

LSM303::vector<double> acc      = (LSM303::vector<double>){    0      ,    0      ,   1      };
LSM303::vector<double> Kp       = (LSM303::vector<double>){  130      ,  130      ,   2      };
LSM303::vector<double> Ki       = (LSM303::vector<double>){   15      ,   15      ,   0      };
LSM303::vector<double> Kd       = (LSM303::vector<double>){   20      ,   20      ,   0      };
LSM303::vector<double> offset   = (LSM303::vector<double>){ -651      , -827.5    , 272.5    };
LSM303::vector<double> QAcc     = (LSM303::vector<double>){    0.0001 ,    0.0001 ,   0.0001 };
LSM303::vector<double> QMag     = (LSM303::vector<double>){    0.0001 ,    0.0001 ,   0.0001 };
LSM303::vector<double> QbiasAcc = (LSM303::vector<double>){    0.005  ,    0.005  ,   0.005  };
LSM303::vector<double> QbiasMag = (LSM303::vector<double>){    0.005  ,    0.005  ,   0.005  };
LSM303::vector<double> RAcc     = (LSM303::vector<double>){    0.005  ,    0.005  ,   0.005  };
LSM303::vector<double> RMag     = (LSM303::vector<double>){    0.005  ,    0.005  ,   0.005  };
LSM303::vector<double> Max      = (LSM303::vector<double>){  200      ,  200      , 200      };
LSM303::vector<double> factor   = (LSM303::vector<double>){  900      ,  900      ,   0      };
LSM303::vector<double> moffset  = (LSM303::vector<double>){  -62.9    ,   67.2    , -67.1    }; 
LSM303::vector<int>    neutral  = (LSM303::vector<int>   ){ 1480      , 1500      ,   0      };

float la,lm,le;
int out = 0;
int startingPoint = 1400;
int timeout = 100000;           // in us
int wait = 300000;              // in us
double T = 20;                  // in degree Celsius
double P = 1013.2;              // in mbar
double theta = 0;               // in rad
const double phi = M_PI/4;      // in rad
double baseline = 1013.2;       // in mbar
double opticalX = 0;
double opticalY = 0;
double hight,angle;
uint32_t timer;
bool isSenderOn;
char statusPressure, statusTemperature;

PID myPIDx(&acc.x , &output.x, &setpoint.x, Kp.x, Ki.x, Kd.x, DIRECT);
PID myPIDy(&acc.y , &output.y, &setpoint.y, Kp.y, Ki.y, Kd.y, DIRECT);
PID myPIDz(&theta , &output.z, &setpoint.z, Kp.z, Ki.z, Kd.z, DIRECT);

int motor[4] = {1000,1000,1000,1000};

const byte interruptPin[4] = {53, 51, 49, 47};
const byte motorPin[4] = {9,10,11,12};
volatile int input[6] = {1000,1000,1000,1000,1000,1000};
volatile uint32_t t[7];

void setup() {
  myServo[0].attach(motorPin[0]);
  myServo[1].attach(motorPin[1]);
  myServo[2].attach(motorPin[2]);
  myServo[3].attach(motorPin[3]);
  myServo[0].writeMicroseconds(motor[0]);
  myServo[1].writeMicroseconds(motor[1]);
  myServo[2].writeMicroseconds(motor[2]);
  myServo[3].writeMicroseconds(motor[3]);
  pinMode(interruptPin[0], INPUT_PULLUP);
  pinMode(interruptPin[1], INPUT_PULLUP);
  pinMode(interruptPin[2], INPUT_PULLUP);
  pinMode(interruptPin[3], INPUT_PULLUP);
  Serial.begin(115200);
  Serial.println("REBOOT");

  // Initialize the sensor (it is important to get calibration values stored on the device).
  if (pressure.begin())
    Serial.println("BMP180 init success");
  else
  {
    // Oops, something went wrong, this is usually a connection p,roblem,
    // see the comments at the top of this sketch for the proper connections.
    Serial.println("BMP180 init fail (disconnected?)\n\n");
    while(1); // Pause forever.
  }
  statusTemperature = pressure.startTemperature();
  if (statusTemperature != 0)
  {
    delay(statusTemperature);
    statusTemperature = pressure.getTemperature(T);
    if (statusTemperature == 0) 
          Serial.println("error retrieving temperature measurement\n");
    else
    {
          Serial.print(T);
          Serial.println(" oC");
          // Start a pressure measurement:
          // The parameter is the oversampling setting, from 0 to 3 (highest res, longest wait).
          // If request is successful, the number of ms to wait is returned.
          // If request is unsuccessful, 0 is returned.
          statusPressure = pressure.startPressure(3);
          if (statusPressure != 0)
          {
              delay(statusPressure);
              statusPressure = pressure.getPressure(P,T);
              if (statusPressure == 0) 
                Serial.println("error retrieving pressure measurement\n");
              else
                baseline = P;
          }
          else Serial.println("error starting pressure measurement\n");
      }
  }
  else Serial.println("error starting temperature measurement\n");
  
  Serial.print("baseline pressure: ");
  Serial.print(baseline);
  Serial.println("mbar");
  Wire.begin();
  compass.init();
  compass.enableDefault();
  compass.read(); 
  // Try to initialise and warn if we couldn't detect the chip
  //if (!gyro.begin(gyro.L3DS20_RANGE_250DPS))
  if (!gyro.begin(gyro.L3DS20_RANGE_500DPS))
  //if (!gyro.begin(gyro.L3DS20_RANGE_2000DPS))
  {
    Serial.println("Oops ... unable to initialize the L3GD20. Check your wiring!");
    while (1);
  }
  attachInterrupt(digitalPinToInterrupt(interruptPin[0]), blink1, RISING);
  Serial.println("start");
  timer = micros();
  t[6] = timer;
  while(micros()-timer<wait){
    Read();
  }
  N = (LSM303::vector<double>){compass.m.x-offset.x,compass.m.y-offset.y,compass.m.z-offset.z};
  LSM303::vector_cross(&N,&acc,&E);
  angle = atan2(E.y,E.x);
  lm = sqrt(LSM303::vector_dot(&N,&N));
  la = sqrt(LSM303::vector_dot(&compass.a,&compass.a));
  gyro.read();
  setpoint.z = - gyro.data.z;
  if(la>0){
    setpoint.x = compass.a.x/la;
    setpoint.y = compass.a.y/la;
    kalAcc.x.set(compass.a.x/la);
    kalAcc.y.set(compass.a.y/la);
    kalAcc.z.set(compass.a.z/la);
  }
  if(lm>0){
    kalMag.x.set(N.x/lm);
    kalMag.y.set(N.y/lm);
    kalMag.z.set(N.z/lm);
  }
  kalAcc.x.setQ(QAcc.x);
  kalAcc.x.setQbias(QbiasAcc.x);
  kalAcc.x.setRmeasure(RAcc.x);
  kalAcc.y.setQ(QAcc.y);
  kalAcc.y.setQbias(QbiasAcc.y);
  kalAcc.y.setRmeasure(RAcc.y);
  kalAcc.z.setQ(QAcc.z);
  kalAcc.z.setQbias(QbiasAcc.z);
  kalAcc.z.setRmeasure(RAcc.z);
  kalMag.x.setQ(QMag.x);
  kalMag.x.setQbias(QbiasMag.x);
  kalMag.x.setRmeasure(RMag.x);
  kalMag.y.setQ(QMag.y);
  kalMag.y.setQbias(QbiasMag.y);
  kalMag.y.setRmeasure(RMag.y);
  kalMag.z.setQ(QMag.z);
  kalMag.z.setQbias(QbiasMag.z);
  kalMag.z.setRmeasure(RMag.z);
  //turn the PID on
  myPIDx.SetOutputLimits(-Max.x,Max.x);
  myPIDy.SetOutputLimits(-Max.y,Max.y);
  myPIDz.SetOutputLimits(-Max.z,Max.z);
  myPIDx.Init();
  myPIDy.Init();
  myPIDz.Init();
}

void Read(){
  if(Serial.available()>0){
      char first = Serial.read();
      if (first=='0'){
        Kp.x = Serial.parseFloat();
        Kp.y = Serial.parseFloat();
        Kp.z = Serial.parseFloat();
        Ki.x = Serial.parseFloat();
        Ki.y = Serial.parseFloat();
        Ki.z = Serial.parseFloat();
        Kd.x = Serial.parseFloat();
        Kd.y = Serial.parseFloat();
        Kd.z = Serial.parseFloat();
        QAcc.x = Serial.parseFloat();
        QAcc.y = Serial.parseFloat();
        QAcc.z = Serial.parseFloat();
        QbiasAcc.x = Serial.parseFloat();
        QbiasAcc.y = Serial.parseFloat();
        QbiasAcc.z = Serial.parseFloat();
        RAcc.x = Serial.parseFloat();
        RAcc.y = Serial.parseFloat();
        RAcc.z = Serial.parseFloat();
        offset.x = Serial.parseFloat();
        offset.y = Serial.parseFloat();
        offset.z = Serial.parseFloat();
        moffset.x = Serial.parseFloat();
        moffset.y = Serial.parseFloat();
        moffset.z = Serial.parseFloat();
        out = Serial.parseInt();
        kalAcc.x.setQ(QAcc.x);
        kalAcc.x.setQbias(QbiasAcc.x);
        kalAcc.x.setRmeasure(RAcc.x);
        kalAcc.y.setQ(QAcc.y);
        kalAcc.y.setQbias(QbiasAcc.y);
        kalAcc.y.setRmeasure(RAcc.y);
        kalAcc.z.setQ(QAcc.z);
        kalAcc.z.setQbias(QbiasAcc.z);
        kalAcc.z.setRmeasure(RAcc.z);
        myPIDx.SetTunings(Kp.x,Ki.x,Kd.x);
        myPIDy.SetTunings(Kp.y,Ki.y,Kd.y);
        myPIDz.SetTunings(Kp.z,Ki.z,Kd.z);
        myPIDx.Reset();
        myPIDy.Reset();
        myPIDz.Reset();
        /*Serial.print("0:");
        Serial.print(Kp.x);
        Serial.print(",");
        Serial.print(Kp.y);
        Serial.print(",");
        Serial.print(Kp.z);
        Serial.print(",");
        Serial.print(Ki.x);
        Serial.print(",");
        Serial.print(Ki.y);
        Serial.print(",");
        Serial.print(Ki.z);
        Serial.print(",");
        Serial.print(Kd.x);
        Serial.print(",");
        Serial.print(Kd.y);
        Serial.print(",");
        Serial.print(Kd.z);
        Serial.print(",");
        Serial.println(out);*/
      } else {
        opticalX = Serial.parseFloat();
        opticalY = Serial.parseFloat();
      }   
   }
}
double temp = 0;
void loop() {  
  compass.read();
  gyro.read();
  Read();
  //Temperature();
  //Pressure();
  uint32_t start = micros();
  double dt = (double)(start - timer) / 1000000; // Calculate delta time in seconds
  timer = start;
  N = (LSM303::vector<double>){compass.m.x-offset.x,compass.m.y-offset.y,compass.m.z-offset.z};
  lm = sqrt(LSM303::vector_dot(&N,&N));
  la = sqrt(LSM303::vector_dot(&compass.a,&compass.a)); 
  if(la>0){
    acc = (LSM303::vector<double>){
      kalAcc.x.get(compass.a.x / la,   (compass.a.y * gyro.data.z - compass.a.z * gyro.data.x) * DEG_TO_RAD / la, dt),
      kalAcc.y.get(compass.a.y / la, - (compass.a.z * gyro.data.y + compass.a.x * gyro.data.z) * DEG_TO_RAD / la, dt),
      kalAcc.z.get(compass.a.z / la,   (compass.a.y * gyro.data.y + compass.a.x * gyro.data.x) * DEG_TO_RAD / la, dt)
    };
    myPIDx.Compute(dt,kalAcc.x.getRate());
    myPIDy.Compute(dt,kalAcc.y.getRate());
    if(lm>0){
      mag = (LSM303::vector<double>){
        kalMag.x.get(N.x / lm,   (N.y * gyro.data.z - N.z * gyro.data.x) * DEG_TO_RAD / lm, dt),
        kalMag.y.get(N.y / lm, - (N.z * gyro.data.y + N.x * gyro.data.z) * DEG_TO_RAD / lm, dt),
        kalMag.z.get(N.z / lm,   (N.y * gyro.data.y + N.x * gyro.data.x) * DEG_TO_RAD / lm, dt)
      }; 
      /*LSM303::vector_cross(&mag,&acc,&E);
      theta = atan2(E.y,E.x)-angle;
      theta = atan2(sin(theta),cos(theta));*/
      //InputZ -= (input[3]-1500)*M_PI/500;
      theta = - gyro.data.z;
      myPIDz.Compute(dt,(theta-temp)/dt);
      temp = theta;
      le = sqrt(LSM303::vector_dot(&E,&E));
      E = (LSM303::vector<double>){
          E.x / le, 
          E.y / le, 
          E.z / le
      };
      LSM303::vector_cross(&acc,&E,&N);
    }
  } 
  output.x+=moffset.x;
  output.y+=moffset.y;
  output.z+=moffset.z;
  motor[0] =   output.y * pow(sin(phi),2) + output.x * pow(cos(phi),2) + input[2] + output.z - opticalX - opticalY-200;
  motor[1] = - output.y * pow(cos(phi),2) + output.x * pow(sin(phi),2) + input[2] - output.z + opticalX - opticalY-200;
  motor[2] = - output.y * pow(sin(phi),2) - output.x * pow(cos(phi),2) + input[2] + output.z + opticalX + opticalY-200;
  motor[3] =   output.y * pow(cos(phi),2) - output.x * pow(sin(phi),2) + input[2] - output.z - opticalX + opticalY-200;
  if((micros()-t[6])<timeout && (isSenderOn || input[2]<startingPoint)){
    isSenderOn = true;
    setpoint.y = - (input[0]-neutral.y)/factor.y;
    setpoint.x =   (input[1]-neutral.x)/factor.x;
    myServo[0].writeMicroseconds(motor[0]);
    myServo[1].writeMicroseconds(motor[1]);
    myServo[2].writeMicroseconds(motor[2]);
    myServo[3].writeMicroseconds(motor[3]);
  } else {
    isSenderOn = false;
    myServo[0].writeMicroseconds(1000);
    myServo[1].writeMicroseconds(1000);
    myServo[2].writeMicroseconds(1000);
    myServo[3].writeMicroseconds(1000);
  }  
  switch(out){
    case 1:
      Serial.print("1:");
      Serial.print(acc.x);
      Serial.print(",");
      Serial.print(setpoint.x);
      Serial.print(",");
      Serial.print(output.x);
      Serial.print(",");
      Serial.print(acc.y);
      Serial.print(",");
      Serial.print(setpoint.y);
      Serial.print(",");
      Serial.print(output.y);
      Serial.print(",");
      Serial.print(theta);
      Serial.print(",");
      Serial.println(output.z);
      break;
    case 2:
      Serial.print("2:");
      Serial.print(acc.x);
      Serial.print(",");
      Serial.print(acc.y);
      Serial.print(",");
      Serial.println(acc.z);
      break;
    case 3:
      Serial.print("3:");
      Serial.print(N.x);
      Serial.print(",");
      Serial.print(N.y);
      Serial.print(",");
      Serial.println(N.z);
      break;
    case 4:
      Serial.print("4:");
      Serial.print(N.x);
      Serial.print(",");
      Serial.print(E.x);
      Serial.print(",");
      Serial.print(acc.x);
      Serial.print(",");
      Serial.print(N.z);
      Serial.print(",");
      Serial.print(E.z);
      Serial.print(",");
      Serial.println(acc.z);
      break;
    case 5:
      Serial.print("5:");
      Serial.print(motor[0]);
      Serial.print(",");
      Serial.print(motor[1]);
      Serial.print(",");
      Serial.print(motor[2]);
      Serial.print(",");
      Serial.println(motor[3]);
      break;
    case 6:
      Serial.print("6:");
      Serial.print(compass.a.x);
      Serial.print(",");
      Serial.print(compass.a.y);
      Serial.print(",");
      Serial.println(compass.a.z);
      break;
    case 7:
      Serial.print("6:");
      Serial.print(compass.m.x);
      Serial.print(",");
      Serial.print(compass.m.y);
      Serial.print(",");
      Serial.println(compass.m.z);
      break;
  }
}

uint32_t t0,t1;
bool restartPressure = true;

void Pressure()
{
  if(restartPressure){
     // Start a pressure measurement:
     // The parameter is the oversampling setting, from 0 to 3 (highest res, longest wait).
     // If request is successful, the number of ms to wait is returned.
     // If request is unsuccessful, 0 is returned.
     statusPressure = pressure.startPressure(3);
     t1 = millis();
  }
  if (statusPressure != 0)
  {
     restartPressure = false;
     if(millis()-t1>=statusPressure){
        statusPressure = pressure.getPressure(P,T);
        restartPressure = true;
        if (statusPressure == 0) 
          Serial.println("error retrieving pressure measurement\n");
        else
          hight = pressure.altitude(P,baseline);
          //Serial.println(P);
     }   
  }
  else Serial.println("error starting pressure measurement\n");
}

bool restartTemperature = true;

void Temperature()
{
  if(restartTemperature){
    statusTemperature = pressure.startTemperature();
    t0 = millis();
  }
  if (statusTemperature != 0)
  {
    restartTemperature = false;
    if (millis()-t0>=statusTemperature){
      statusTemperature = pressure.getTemperature(T);
      restartTemperature = true;
      if (statusTemperature == 0) 
          Serial.println("error retrieving pressure measurement\n");
      /*else
          Serial.println(T);*/
    }
  }
  else Serial.println("error starting temperature measurement\n");
}

void blink1() {
  t[0] = micros();
  attachInterrupt(digitalPinToInterrupt(interruptPin[1]), blink2, RISING);
}

void blink2() {
  t[1] = micros();
  input[0] = t[1] - t[0];
  attachInterrupt(digitalPinToInterrupt(interruptPin[1]), blink3, FALLING);
}

void blink3() {
  t[2] = micros();
  input[1] = t[2] - t[1];
  attachInterrupt(digitalPinToInterrupt(interruptPin[2]), blink4, RISING);
  detachInterrupt(digitalPinToInterrupt(interruptPin[1]));
}

void blink4() {
  t[3] = micros();
  input[2] = t[3] - t[2];
  attachInterrupt(digitalPinToInterrupt(interruptPin[2]), blink5, FALLING);
}

void blink5() {
  t[4] = micros();
  input[3] = t[4] - t[3];
  attachInterrupt(digitalPinToInterrupt(interruptPin[3]), blink6, RISING);
  detachInterrupt(digitalPinToInterrupt(interruptPin[2]));
}

void blink6() {
  t[5] = micros();
  input[4] = t[5] - t[4];
  attachInterrupt(digitalPinToInterrupt(interruptPin[3]), blink7, FALLING);
}

void blink7() {
  t[6] = micros();
  input[5] = t[6] - t[5];
  detachInterrupt(digitalPinToInterrupt(interruptPin[3]));
}
